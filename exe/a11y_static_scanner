#!/usr/bin/env ruby
# frozen_string_literal: true

# Static accessibility scanner for development
# Scans all view files and shows accessibility errors
# Usage: Add to Procfile.dev as: a11y: bundle exec a11y_static_scanner

require 'bundler/setup'

# Load Rails environment
rails_root = Dir.pwd
while rails_root != '/' && !File.exist?(File.join(rails_root, 'config', 'environment.rb'))
  rails_root = File.dirname(rails_root)
end

if File.exist?(File.join(rails_root, 'config', 'environment.rb'))
  Dir.chdir(rails_root)
  require File.join(rails_root, 'config', 'environment')
end

# Require the gem
begin
  require 'rails_accessibility_testing'
  require 'rails_accessibility_testing/static_file_scanner'
  require 'rails_accessibility_testing/file_change_tracker'
rescue LoadError => e
  $stderr.puts "‚ùå Error loading rails_accessibility_testing gem: #{e.message}"
  $stderr.puts "   Make sure the gem is installed: bundle install"
  exit 1
end

# Format errors with file locations and line numbers
def format_errors(errors, warnings)
  return "" if errors.empty? && warnings.empty?
  
  output = []
  
  # Group errors by file
  errors_by_file = errors.group_by { |e| e[:file] }
  warnings_by_file = warnings.group_by { |w| w[:file] }
  
  # Show errors first
  if errors.any?
    output << "\n" + "="*70
    output << "‚ùå #{errors.length} error#{'s' if errors.length != 1} found"
    output << "="*70
    output << ""
    
    errors_by_file.each_with_index do |(file_path, file_errors), file_index|
      output << "" if file_index > 0
      
      # Show relative path
      relative_path = file_path.sub(%r{^.*app/views/}, 'app/views/')
      output << "üìù #{relative_path} (#{file_errors.length} error#{'s' if file_errors.length != 1})"
      
      file_errors.each do |error|
        error_line = "   ‚Ä¢ #{error[:type]}"
        
        # Add line number if available
        if error[:line]
          error_line += " [Line #{error[:line]}]"
        end
        
        # Add element identifier
        element_id = error[:element][:id]
        element_href = error[:element][:href]
        element_src = error[:element][:src]
        
        if element_id && !element_id.to_s.strip.empty?
          error_line += " [id: #{element_id}]"
        elsif element_href && !element_href.to_s.strip.empty?
          href_display = element_href.length > 30 ? "#{element_href[0..27]}..." : element_href
          error_line += " [href: #{href_display}]"
        elsif element_src && !element_src.to_s.strip.empty?
          src_display = element_src.length > 30 ? "#{element_src[0..27]}..." : element_src
          error_line += " [src: #{src_display}]"
        end
        
        output << error_line
      end
    end
    
    output << ""
    output << "="*70
  end
  
  # Show warnings if any
  if warnings.any?
    output << "\n" + "="*70
    output << "‚ö†Ô∏è  #{warnings.length} warning#{'s' if warnings.length != 1} found"
    output << "="*70
    output << ""
    
    warnings_by_file.each_with_index do |(file_path, file_warnings), file_index|
      output << "" if file_index > 0
      
      # Show relative path
      relative_path = file_path.sub(%r{^.*app/views/}, 'app/views/')
      output << "üìù #{relative_path} (#{file_warnings.length} warning#{'s' if file_warnings.length != 1})"
      
      file_warnings.each do |warning|
        warning_line = "   ‚Ä¢ #{warning[:type]}"
        
        # Add line number if available
        if warning[:line]
          warning_line += " [Line #{warning[:line]}]"
        end
        
        # Add element identifier
        element_id = warning[:element][:id]
        element_href = warning[:element][:href]
        element_src = warning[:element][:src]
        
        if element_id && !element_id.to_s.strip.empty?
          warning_line += " [id: #{element_id}]"
        elsif element_href && !element_href.to_s.strip.empty?
          href_display = element_href.length > 30 ? "#{element_href[0..27]}..." : element_href
          warning_line += " [href: #{href_display}]"
        elsif element_src && !element_src.to_s.strip.empty?
          src_display = element_src.length > 30 ? "#{element_src[0..27]}..." : element_src
          warning_line += " [src: #{src_display}]"
        end
        
        output << warning_line
      end
    end
    
    output << ""
    output << "="*70
  end
  
  output.join("\n")
end

# Get all view files
def get_all_view_files
  return [] unless defined?(Rails) && Rails.root
  
  view_dir = Rails.root.join('app', 'views')
  return [] unless File.directory?(view_dir)
  
  extensions = %w[erb haml slim]
  view_files = []
  
  extensions.each do |ext|
    # Find all HTML view files (exclude partials that start with _)
    pattern = File.join(view_dir, '**', "*.html.#{ext}")
    Dir.glob(pattern).each do |file|
      # Skip partials (files starting with _)
      next if File.basename(file).start_with?('_')
      # Skip layout files
      next if file.include?('/layouts/')
      view_files << file
    end
  end
  
  view_files.sort
end

# Main scanner
begin
  puts "\n" + "="*70
  puts "üîç Static Accessibility Scanner"
  puts "="*70
  puts "üìÅ Scanning all view files..."
  puts ""
  
  view_files = get_all_view_files
  
  if view_files.empty?
    puts "‚ö†Ô∏è  No view files found to scan"
    exit 0
  end
  
  puts "üìã Found #{view_files.length} view file#{'s' if view_files.length != 1} to scan"
  puts ""
  
  # Load config
  begin
    config = RailsAccessibilityTesting::Config::YamlLoader.load(profile: :development)
    ignore_warnings = config.dig('summary', 'ignore_warnings') || false
    static_config = config['static_scanner'] || {}
    scan_changed_only = static_config.fetch('scan_changed_only', true)
    check_interval = static_config.fetch('check_interval', 3)
    full_scan_on_startup = static_config.fetch('full_scan_on_startup', true)
  rescue StandardError
    ignore_warnings = false
    scan_changed_only = true
    check_interval = 3
    full_scan_on_startup = true
  end
  
  # Determine which files to scan
  files_to_scan = []
  
  if scan_changed_only && !full_scan_on_startup
    # Only scan changed files from the start (no full scan on startup)
    changed = RailsAccessibilityTesting::FileChangeTracker.changed_files(view_files)
    if changed.empty?
      puts "‚úÖ No files changed since last scan"
      puts "üîÑ Scanner running continuously - watching for file changes..."
      puts "   Press Ctrl-C to stop"
      puts ""
      
      # Just watch for changes
      loop do
        sleep check_interval
        changed = RailsAccessibilityTesting::FileChangeTracker.changed_files(view_files)
        if changed.any?
          puts "\nüìù #{changed.length} file#{'s' if changed.length != 1} changed - scanning..."
          files_to_scan = changed
          break
        end
      end
    else
      puts "üìù Found #{changed.length} changed file#{'s' if changed.length != 1} to scan"
      files_to_scan = changed
    end
  elsif scan_changed_only && full_scan_on_startup
    # Always scan all files on startup when full_scan_on_startup is true
    # This ensures every new instance of bin/dev runs a full scan
    puts "üìã Scanning all #{view_files.length} file#{'s' if view_files.length != 1} on startup"
    files_to_scan = view_files
  else
    # Scan all files every time (scan_changed_only is false)
    puts "üìã Scanning all #{view_files.length} file#{'s' if view_files.length != 1}"
    files_to_scan = view_files
  end
  
  # Scan files
  all_errors = []
  all_warnings = []
  
  if files_to_scan.any?
    files_to_scan.each do |view_file|
      scanner = RailsAccessibilityTesting::StaticFileScanner.new(view_file)
      result = scanner.scan
      
      errors = result[:errors] || []
      warnings = result[:warnings] || []
      
      all_errors.concat(errors)
      all_warnings.concat(warnings) unless ignore_warnings
      
      print "."
      $stdout.flush
    end
    
    # Update state with scanned files
    RailsAccessibilityTesting::FileChangeTracker.update_state(files_to_scan)
    
    puts ""
    puts ""
    
    # Show results
    if all_errors.any? || (all_warnings.any? && !ignore_warnings)
      puts format_errors(all_errors, ignore_warnings ? [] : all_warnings)
      puts ""
      puts "üí° Fix the errors above - scanner will re-run automatically"
      puts ""
    else
      puts "‚úÖ All #{files_to_scan.length} scanned file#{'s' if files_to_scan.length != 1} passed accessibility checks!"
      puts ""
    end
  end
  
  # Keep scanner running continuously - re-scan files when they change
  if scan_changed_only
    # Always show waiting message after scanning
    puts "üîÑ Scanner running continuously - watching for file changes..."
    puts "   Press Ctrl-C to stop"
    puts ""
    
    loop do
      sleep check_interval
      
      # Check for changed files using FileChangeTracker
      changed = RailsAccessibilityTesting::FileChangeTracker.changed_files(view_files)
      
      if changed.any?
        puts "\nüìù #{changed.length} file#{'s' if changed.length != 1} changed - re-scanning..."
        puts ""
        
        # Scan only changed files
        all_errors = []
        all_warnings = []
        
        changed.each do |view_file|
          scanner = RailsAccessibilityTesting::StaticFileScanner.new(view_file)
          result = scanner.scan
          
          errors = result[:errors] || []
          warnings = result[:warnings] || []
          
          all_errors.concat(errors)
          all_warnings.concat(warnings) unless ignore_warnings
          
          print "."
          $stdout.flush
        end
        
        # Update state
        RailsAccessibilityTesting::FileChangeTracker.update_state(changed)
        
        puts ""
        puts ""
        
        # Show results
        if all_errors.any? || (all_warnings.any? && !ignore_warnings)
          puts format_errors(all_errors, ignore_warnings ? [] : all_warnings)
          puts ""
          puts "üí° Fix the errors above - scanner will re-run automatically"
          puts ""
        else
          puts "‚úÖ All #{changed.length} scanned file#{'s' if changed.length != 1} passed accessibility checks!"
          puts ""
        end
      end
    end
  else
    # Not watching for changes - exit after scan
    puts "‚úÖ Scan complete"
  end
  
rescue Interrupt
  puts "\n\nüëã Scanner stopped"
  exit 0
rescue StandardError => e
  puts "\n\n‚ùå Error: #{e.message}"
  puts e.backtrace.first(5).join("\n")
  exit 1
end

