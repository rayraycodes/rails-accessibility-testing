require 'rails_helper'

RSpec.describe 'All Pages Accessibility', type: :system do
  # Test all view files for accessibility
  # Generated automatically by rails_a11y:install generator
  
  # Load config to determine scanning strategy
  def self.scan_config
    return { 'scan_strategy' => 'paths' } unless defined?(Rails) && Rails.application
    
    begin
      require 'rails_accessibility_testing/config/yaml_loader'
      profile = Rails.env.test? ? :test : :development
      config = RailsAccessibilityTesting::Config::YamlLoader.load(profile: profile)
      { 'scan_strategy' => config['scan_strategy'] || 'paths' }
    rescue StandardError
      { 'scan_strategy' => 'paths' }
    end
  end
  
  # Helper method to get all view files (non-partials)
  def self.get_all_view_files
    return [] unless defined?(Rails) && Rails.root
    
    view_dir = Rails.root.join('app', 'views')
    return [] unless File.directory?(view_dir)
    
    extensions = %w[erb haml slim]
    view_files = []
    
    extensions.each do |ext|
      # Find all HTML view files (exclude partials that start with _)
      pattern = File.join(view_dir, '**', "*.html.#{ext}")
      Dir.glob(pattern).each do |file|
        # Skip partials (files starting with _)
        next if File.basename(file).start_with?('_')
        # Skip layout files
        next if file.include?('/layouts/')
        view_files << file
      end
    end
    
    view_files.sort
  end
  
  # Helper method to generate path directly from view file (faster than route iteration)
  def self.generate_path_from_view_file(view_file)
    return nil unless defined?(Rails) && Rails.application
    
    # Extract controller and action from view file path
    # Example: app/views/items/search_result.html.erb -> items#search_result
    relative_path = view_file.sub(%r{^.*app/views/}, '').sub(/\.html\.(erb|haml|slim)$/, '')
    parts = relative_path.split('/')
    
    return nil if parts.empty?
    
    controller = parts[0..-2].join('/')
    action = File.basename(parts.last)
    
    # Use Rails URL helpers to generate path directly from controller/action
    # This is faster than iterating through all routes
    begin
      # Try to generate URL using Rails URL helpers
      # This uses Rails' optimized route generation
      url_helper_name = "#{controller.gsub('/', '_')}_#{action}_path"
      
      # Handle namespaced controllers (e.g., admin/users -> admin_users)
      url_helper_name = url_helper_name.gsub(/[^a-z0-9_]/, '_')
      
      # Try to use the URL helper if it exists
      if Rails.application.routes.url_helpers.respond_to?(url_helper_name)
        path = Rails.application.routes.url_helpers.send(url_helper_name)
        return { path: path, controller: controller, action: action, view_file: view_file }
      end
      
      # Fallback: Try with index if action might be index
      if action != 'index'
        index_helper_name = "#{controller.gsub('/', '_')}_index_path"
        index_helper_name = index_helper_name.gsub(/[^a-z0-9_]/, '_')
        if Rails.application.routes.url_helpers.respond_to?(index_helper_name)
          # For non-index actions, we might need to construct differently
          # Try the action path first
        end
      end
      
      # Alternative: Use url_for directly (most reliable)
      begin
        # Create a mock controller context to use url_for
        path = Rails.application.routes.url_for(
          controller: controller,
          action: action,
          only_path: true
        )
        return { path: path, controller: controller, action: action, view_file: view_file }
      rescue StandardError => e
        # url_for failed, try route matching as fallback
      end
      
      # Last resort: Find route by matching controller/action
      # This is slower but more reliable for edge cases
      Rails.application.routes.routes.each do |route|
        next unless route.verb.to_s.include?('GET')
        
        begin
          route_params = route.defaults
          route_controller = route_params[:controller]
          route_action = route_params[:action]
          
          # Match controller and action
          if route_controller == controller && route_action == action
            path = RailsAccessibilityTesting::ChangeDetector.route_to_path(route)
            return { path: path, controller: controller, action: action, view_file: view_file } if path
          end
        rescue StandardError
          next
        end
      end
    rescue StandardError => e
      # If all methods fail, return nil
    end
    
    nil
  end
  
  # Helper method to get all testable routes (path-based strategy)
  def self.get_testable_routes
    return [] unless defined?(Rails) && Rails.application
    
    Rails.application.routes.routes.select do |route|
      next false unless route.verb.to_s.include?('GET')
      
      path_spec = route.path.spec.to_s
      
      # Exclude API routes, internal Rails routes, and format-specific routes
      next false if path_spec =~ /\.(json|xml|js)/
      next false if path_spec =~ /rails/
      next false if path_spec =~ /active_storage/
      next false if path_spec =~ /action_cable/
      next false if path_spec =~ /letter_opener/
      next false if path_spec =~ /up/
      next false if path_spec =~ /recede_historical_location/
      next false if path_spec =~ /resume_historical_location/
      next false if path_spec =~ /refresh_historical_location/
      
      # Skip routes with complex requirements
      next false if path_spec.include?('destroy') || path_spec.include?('delete')
      
      # Skip routes with multiple required params (too complex to test automatically)
      param_count = path_spec.scan(/\(:(\w+)\)/).length
      next false if param_count > 1
      
      true
    end
  end
  
  # Determine which strategy to use and get test items
  config = scan_config
  strategy = config['scan_strategy'] || 'paths'
  
  if strategy == 'view_files'
    # View-file-based scanning strategy - scan files directly (faster!)
    view_files = get_all_view_files
    
    view_files.each do |view_file|
      # Generate path directly from view file (faster than route iteration)
      route_info = generate_path_from_view_file(view_file)
      next unless route_info && route_info[:path]
      
      path = route_info[:path]
      it "checks accessibility for #{view_file}" do
        begin
          visit path
          
          # Wait for page to load
          sleep 0.5
          
          # Skip if redirected to sign in (requires authentication)
          if page.current_url.include?('sign_in') || page.current_url.include?('login')
            skip "Skipping #{view_file}: requires authentication"
          elsif page.has_content?('Error') || page.has_content?('404') || page.has_content?('Not Found')
            skip "Skipping #{view_file}: page not found or error"
          else
            # Page loaded successfully, run accessibility checks
            check_comprehensive_accessibility
          end
        rescue => e
          # Skip routes that can't be accessed
          skip "Skipping #{view_file}: #{e.message}"
        end
      end
    end
  else
    # Path-based scanning strategy (default)
    get_testable_routes.each do |route|
      path = RailsAccessibilityTesting::ChangeDetector.route_to_path(route)
      next unless path
      
      it "checks accessibility for #{path}" do
        begin
          visit path
          
          # Wait for page to load
          sleep 0.5
          
          # Skip if redirected to sign in (requires authentication)
          if page.current_url.include?('sign_in') || page.current_url.include?('login')
            skip "Skipping #{path}: requires authentication"
          elsif page.has_content?('Error') || page.has_content?('404') || page.has_content?('Not Found')
            skip "Skipping #{path}: page not found or error"
          else
            # Page loaded successfully, run accessibility checks
            check_comprehensive_accessibility
          end
        rescue => e
          # Skip routes that can't be accessed
          skip "Skipping #{path}: #{e.message}"
        end
      end
    end
  end
end
